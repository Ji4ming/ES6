<!--ECMAScript6Notes_Ji4ming_20200615-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> ECMAScript6Notes_Ji4ming </title>
</head>
<body>
    <script>
        /*
    // Reference: https://es6.ruanyifeng.com/#README

    // 给变量赋值：
                let [foo, [[bar], baz]] = [1, [[2], 3]];
                foo // 1
                bar // 2
                baz // 3

                let [ , , third] = ["foo", "bar", "baz"];
                third // "baz"

                let [x, , y] = [1, 2, 3];
                x // 1
                y // 3

                let [head, ...tail] = [1, 2, 3, 4];
                head // 1
                tail // [2, 3, 4]

                let [x, y, ...z] = ['a'];
                x // "a"
                y // undefined -> * 重要 *
                z // [] -> * 重要 *

                let [a, [b], d] = [1, [2, 3], 4];
                a // 1
                b // 2
                d // 4

            赋默认值：
                let [foo = true] = [];
                foo // true

                let [x = 1] = [null];
                x // null

                let [x, y = 'b'] = ['a'];
                x // a
                y // b

                let [x, y = 'b'] = ['a', undefined];
                x // a
                y // b

                function f() {
                    console.log('aaa');
                }
                let [x = f()] = [1];
                // x = 1, 因为x能取到值，所以函数f根本不会执行

            报错情况(等号右侧不是数组)
                let [foo] = 1;
                let [foo] = false;
                let [foo] = NaN;
                let [foo] = undefined;
                let [foo] = null;
                let [foo] = {};

            给对象赋值：
                let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
                foo // "aaa"
                bar // "bbb"

                let { baz } = { foo: 'aaa', bar: 'bbb' };
                baz // undefined * 重要 *

            特别好的两个例子: 这里的 baz 和 f 都是形参
                let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
                baz // "aaa"

                let obj = { first: 'hello', last: 'world' };
                let { first: f, last: l } = obj;
                f // 'hello'
                l // 'world'

            嵌套结构,特别好的几个例子：
                let obj = {
                    p: [
                        'Hello',
                        { y: 'World' }
                    ]
                };

                let { p, p: [x, { y }] } = obj;
                x // "Hello"
                y // "World"
                p // ["Hello", {y: "World"}]

            函数解构：
                function move({x, y} = { x: 0, y: 0 }) {
                    return [x, y];
                }

                move({x: 3, y: 8}); // [3, 8]
                move({x: 3}); // [3, undefined]
                move({}); // [undefined, undefined]
                move(); // [0, 0]
        */

        /*
    // 函数表达式：
                let a = 'secret';
                let f = function () {
                    return a;
                };

            函数声明语句：
                let a = 'secret';
                function f() {
                    return a;
                }
        */

        /*
    // string methods
            includes()：返回布尔值，表示是否找到了参数字符串。
            startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
            endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
            这三个方法都支持第二个参数，表示开始搜索的位置。
                let s = 'Hello world!';
                s.startsWith('world', 6) // true
                s.endsWith('Hello', 5) // true
                s.includes('Hello', 6) // false

            repeat()：返回一个新字符串，表示将原字符串重复n次。
                'na'.repeat(2)              // "nana"
                'na'.repeat(0)              // ""
                'na'.repeat(NaN)            // ""
                'na'.repeat(Infinity)       // RangeError
                'na'.repeat(-1)             // RangeError
                'na'.repeat(2.9)            // "nana"
                'na'.repeat(-0.9)           // ""
                'na'.repeat('na')           // ""   ->  如果repeat的参数是字符串，则会先转换成数字。

            padStart():用于头部补全
            padEnd():用于尾部补全。
                'x'.padStart(5, 'ab') // 'ababx'
                'x'.padStart(4, 'ab') // 'abax'
                'x'.padEnd(5, 'ab') // 'xabab'
                'x'.padEnd(4, 'ab') // 'xaba'
            如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。
                'xxx'.padStart(2, 'ab') // 'xxx'
                'xxx'.padEnd(2, 'ab') // 'xxx'
            如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。
                'abc'.padStart(10, '0123456789')
            如果省略第二个参数，默认使用空格补全长度。
                'x'.padStart(4) // '   x'
                'x'.padEnd(4) // 'x   '

            trimStart():消除字符串头部的空格
            trimEnd():消除尾部的空格。
                const s = '  abc  ';
                s.trim() // "abc"
                s.trimStart() // "abc  "
                s.trimEnd() // "  abc"
        */

        /*
    // Number Methods
            Number.isFinite()用来检查一个数值是否为有限的（finite), 如果参数类型不是数值，Number.isFinite一律返回false
            Number.isFinite(0.8); // true
            Number.isFinite(NaN); // false
            Number.isFinite(Infinity); // false
            Number.isFinite(-Infinity); // false
            Number.isFinite('foo'); // false
            Number.isFinite('15'); // false
            Number.isFinite(true); // false

            Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。
            isNaN(NaN) // true
            isNaN("NaN") // true
            Number.isNaN(NaN) // true
            Number.isNaN("NaN") // false
            Number.isNaN(1) // false

            Number.parseInt('12.34') // 12
            Number.parseFloat('123.45#') // 123.45

            Number.isInteger()

            Number.EPSILON的实质是一个可以接受的最小误差范围。
        */

        /*
    // Math methods
            Math.trunc方法用于去除一个数的小数部分，返回整数部分。对于非数值，Math.trunc内部使用Number方法将其先转为数值。
            对于空值和无法截取整数的值，返回NaN。

            Math.trunc(4.9) // 4
            Math.trunc(false) // 0
            Math.trunc(null) // 0
            Math.trunc(NaN);      // NaN
            Math.trunc('foo');    // NaN
            Math.trunc();         // NaN
            Math.trunc(undefined) // NaN

            Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
            参数为正数，返回+1；
            参数为负数，返回-1；
            参数为 0，返回0；
            参数为-0，返回-0;
            其他值，返回NaN。

            Math.cbrt()方法用于计算一个数的立方根。

            Math.hypot方法返回所有参数的平方和的平方根。  // 勾股定理

            Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1

            Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN

            Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN

            Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。

            Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
            Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
            Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
            Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
            Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
            Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）

            指数运算符（**）这个运算符的一个特点是右结合，多个指数运算符连用时，是从最右边开始计算的。
                2 ** 3 ** 2     // 等同于 2 ** (3 ** 2) = 512
                let a = 1.5;
                a **= 2;    // 等同于 a = a * a;
                let b = 4;
                b **= 3;    // 等同于 b = b * b * b;
        */

        /*
    // function
            通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，
            实际上这个参数是没法省略的。
                // 例一
                function f(x = 1, y) {
                    return [x, y];
                }

                f() // [1, undefined]
                f(2) // [2, undefined]
                f(, 1) // 报错
                f(undefined, 1) // [1, 1]

                // 例二
                function f(x, y = 5, z) {
                    return [x, y, z];
                }

                f() // [undefined, 5, undefined]
                f(1) // [1, 5, undefined]
                f(1, ,2) // 报错
                f(1, undefined, 2) // [1, 5, 2]

            函数的 length 属性:
            指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
                (function (a) {}).length // 1
                (function (a = 5) {}).length // 0
                (function (a, b, c = 5) {}).length // 2
                (function (a = 0, b, c) {}).length // 0
                (function (a, b = 1, c) {}).length // 1
            上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c
            指定了默认值，因此length属性等于3减去1，最后得到2。这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传
            入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。如果设置了默认值的参数不是尾参数，那么length属性也不再计入
            后面的参数了。

            rest -> (a, ...b), 函数的length属性，不包括 rest 参数。
                (function(a) {}).length  // 1
                (function(...a) {}).length  // 0
                (function(a, ...b) {}).length  // 1

            参数变量是默认声明的，所以不能用let或const再次声明。
                function foo(x = 5) {
                    let x = 1; // error
                    const x = 2; // error
                }

            函数的 name 属性，返回该函数的函数名

            箭头函数 * 重要 *
                var f = v => v;
                // 等同于
                var f = function (v) {
                    return v;
                };

            如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
            如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。
                let fn = () => void doesNotReturn();

            尾递归优化 -> 8. 函数的拓展
        */

        /*
    // Array
            扩展运算符 -> 主要用于函数调用
            扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
                console.log(...[1, 2, 3])           // 1 2 3
                console.log(1, ...[2, 3, 4], 5)     // 1 2 3 4 5
                [...document.querySelectorAll('div')]  // [<div>, <div>, <div>]

            如果扩展运算符后面是一个空数组，则不产生任何效果。
                [...[], 1]      // [1]

            由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
                // ES5 的写法
                function f(x, y, z) {
                    // ...
                }
                var args = [0, 1, 2];
                f.apply(null, args);

                // ES6的写法
                function f(x, y, z) {
                  // ...
                }
                let args = [0, 1, 2];
                f(...args);

            复制数组
                const a1 = [1, 2];
                // 写法一
                const a2 = [...a1];
                // 写法二
                const [...a2] = a1;
            上面的两种写法，a2都是a1的克隆。

            合并数组
                const arr1 = ['a', 'b'];
                const arr2 = ['c'];
                const arr3 = ['d', 'e'];

                // ES5 的合并数组
                arr1.concat(arr2, arr3);
                // [ 'a', 'b', 'c', 'd', 'e' ]

                // ES6 的合并数组
                [...arr1, ...arr2, ...arr3]
                // [ 'a', 'b', 'c', 'd', 'e' ]

            Array.of方法用于将一组值，转换为数组。
                Array.of(3, 11, 8) // [3,11,8]
                Array.of(3) // [3]
                Array.of(3).length // 1
            这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。
                Array() // []
                Array(3) // [, , ,]
                Array(3, 11, 8) // [3, 11, 8]
            上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。
            参数个数只有一个时，实际上是指定数组的长度。

            array 覆盖
            数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，
            会修改当前数组。它接受三个参数。
                target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
                start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
                end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。
                    Array.prototype.copyWithin(target, start = 0, end = this.length)
                    // 将3号位复制到0号位
                    [1, 2, 3, 4, 5].copyWithin(0, 3, 4)         // [4, 2, 3, 4, 5]

                    // -2相当于3号位，-1相当于4号位 -> 负数表示从右面开始数
                    [1, 2, 3, 4, 5].copyWithin(0, -2, -1)       // [4, 2, 3, 4, 5]

            find -> 找到第一个
            fill -> 填充全部
            next
            includes(content, [position])
            flat -> 展开嵌套
            flatMap -> 展开一层

            entries()，keys() 和 values()
                for (let index of ['a', 'b'].keys()) {
                    console.log(index);
                }
                // 0
                // 1

                for (let elem of ['a', 'b'].values()) {
                    console.log(elem);
                }
                // 'a'
                // 'b'

                for (let [index, elem] of ['a', 'b'].entries()) {
                    console.log(index, elem);
                }
                // 0 "a"
                // 1 "b"
        */

        /*
    // object
                let user = {
                    name: 'test'
                };

                let foo = {
                    bar: 'baz'
                };

                console.log(user, foo)
                // {name: "test"} {bar: "baz"}
                console.log({user, foo})
                // {user: {name: "test"}, foo: {bar: "baz"}}

            解构赋值：
                let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
                x // 1
                y // 2
                z // { a: 3, b: 4 }

            由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。
                let { ...z } = null; // 运行时错误
                let { ...z } = undefined; // 运行时错误

            解构赋值必须是最后一个参数，否则会报错。
                let { ...x, y, z } = someObject; // 句法错误
                let { x, ...y, ...z } = someObject; // 句法错误

                const o = Object.create({ x: 1, y: 2 });
                o.z = 3;

                let { x, ...newObj } = o;
                let { y, z } = newObj;
                x // 1
                y // undefined
                z // 3

            解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。
                function baseFunction({ a, b }) {
                    // ...
                }
                function wrapperFunction({ x, y, ...restConfig }) {
                    // 使用 x 和 y 参数进行操作
                    // 其余参数传给原始函数
                return baseFunction(restConfig);
                }
            上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，
            并且保留原始函数的行为。

            扩展运算符：
            对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
                let z = { a: 3, b: 4 };
                let n = { ...z };
                n // { a: 3, b: 4 }

            由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。
                let foo = { ...['a', 'b', 'c'] };
                foo
                // {0: "a", 1: "b", 2: "c"}

            如果扩展运算符后面是一个空对象，则没有任何效果。
                {...{}, a: 1}
                // { a: 1 }

            如果扩展运算符后面不是对象，则会自动将其转为对象。
                // 等同于 {...Object(1)}
                {...1} // {}

            如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。
                {...'hello'}
                // {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}

            扩展运算符可以用于合并两个对象。
                let ab = { ...a, ...b };

            如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。
                // 写法二
                const clone2 = Object.assign(
                    Object.create(Object.getPrototypeOf(obj)),
                    obj
                );

                // 写法三
                const clone3 = Object.create(
                    Object.getPrototypeOf(obj),
                    Object.getOwnPropertyDescriptors(obj)
                )

            如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。
                let newVersion = {
                    ...previousVersion,
                    name: 'New Name' // Override the name property
                };

            如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。
                let aWithDefaults = { x: 1, y: 2, ...a };

            链判断运算符：
            编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取message.body.user.firstName，安全的写法是写成下面这样。
                // 错误的写法
                const  firstName = message.body.user.firstName;

                // 正确的写法
                const firstName = (message
                    && message.body
                    && message.body.user
                    && message.body.user.firstName) || 'default';
            上面例子中，firstName属性在对象的第四层，所以需要判断四次，每一层是否有值。

                const firstName = message?.body?.user?.firstName || 'default';
                const fooValue = myForm.querySelector('input[name=foo]')?.value
            上面代码使用了?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。

            下面是判断对象方法是否存在，如果存在就立即执行的例子。
                iterator.return?.()
            上面代码中，iterator.return如果有定义，就会调用该方法，否则iterator.return直接返回undefined，不再执行?.后面的部分。

            链判断运算符有三种用法。
                obj?.prop // 对象属性
                obj?.[expr] // 同上
                func?.(...args) // 函数或对象方法的调用

            为了避免这种情况，ES2020 引入了一个新的 Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。
                const headerText = response.settings.headerText ?? 'Hello, world!';
                const animationDuration = response.settings.animationDuration ?? 300;
                const showSplashScreen = response.settings.showSplashScreen ?? true;
            上面代码中，默认值只有在左侧属性值为null或undefined时，才会生效。
            这个运算符的一个目的，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值。
            上面代码中，response.settings如果是null或undefined，就会返回默认值300。

            ??有一个运算优先级问题，它与&&和||的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。

            Object.is()
                Object.is('foo', 'foo')         // true
                Object.is({}, {})               // false
                Object.is(+0, -0)               // false
                Object.is(NaN, NaN)             // true

            Object.assign()
            Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
            Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。
                const target = { a: 1, b: 1 };
                const source1 = { b: 2, c: 2 };
                const source2 = { c: 3 };

                Object.assign(target, source1, source2);
                target // {a:1, b:2, c:3}
            Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。
            注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。

            如果该参数不是对象，则会先转成对象，然后返回。
                typeof Object.assign(2) // "object"

            由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。
                Object.assign(undefined) // 报错
                Object.assign(null) // 报错

            如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味
            着，如果undefined和null不在首参数，就不会报错。
                let obj = {a: 1};
                Object.assign(obj, undefined) === obj // true
                Object.assign(obj, null) === obj // true

            其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
                const v1 = 'abc';
                const v2 = true;
                const v3 = 10;

                const obj = Object.assign({}, v1, v2, v3);
                console.log(obj); // { "0": "a", "1": "b", "2": "c" }

            Object.assign方法有很多用处:
            （1）为对象添加属性
            （2）为对象添加方法
            （3）克隆对象
            （4）合并多个对象
            （5）为属性指定默认值

            Object.setPrototypeOf()
            Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推
            荐的设置原型对象的方法。
                let proto = {};
                let obj = { x: 10 };
                Object.setPrototypeOf(obj, proto);

                proto.y = 20;
                proto.z = 40;

                obj.x // 10
                obj.y // 20
                obj.z // 40

            如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。
                Object.setPrototypeOf(1, {}) === 1 // true
                Object.setPrototypeOf('foo', {}) === 'foo' // true
                Object.setPrototypeOf(true, {}) === true // true
            由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。

            Object.getPrototypeOf()
            该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。
                function Rectangle() {
                  // ...
                }

                const rec = new Rectangle();

                Object.getPrototypeOf(rec) === Rectangle.prototype
                // true

                Object.setPrototypeOf(rec, Object.prototype);
                Object.getPrototypeOf(rec) === Rectangle.prototype
                // false
            如果参数是undefined或null，它们无法转为对象，所以会报错。

            // Object.keys()，Object.values()，Object.entries()
            * 非常重要 *

            Object.values会过滤属性名为 Symbol 值的属性。
                Object.values({ [Symbol()]: 123, foo: 'abc' });
                // ['abc']
            如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。
                Object.values('foo')
                // ['f', 'o', 'o']
            上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是
            各个字符组成的一个数组。

            如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values
            会返回空数组。
                Object.values(42) // []
                Object.values(true) // []

            Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
            Object.entries的基本用途是遍历对象的属性
                const obj = { foo: 'bar', baz: 42 };
                Object.entries(obj)
                // [ ["foo", "bar"], ["baz", 42] ]

            如果原对象的属性名是一个 Symbol 值，该属性会被忽略。
                // Object.fromEntries()

            Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
                Object.fromEntries([
                  ['foo', 'bar'],
                  ['baz', 42]
                ])
                // { foo: "bar", baz: 42 }
            该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。
        */

        /*
    // Symbol
                let s = Symbol();
                typeof s        // "symbol"

                let s1 = Symbol('foo');
                let s2 = Symbol('bar');
                s1 // Symbol(foo)
                s2 // Symbol(bar)
                s1.toString() // "Symbol(foo)"
                s2.toString() // "Symbol(bar)"
            上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描
            述，输出的时候就能够分清，到底是哪一个值。

            如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。
                const obj = {
                  toString() {
                    return 'abc';
                  }
                };
                const sym = Symbol(obj);
                sym // Symbol(abc)

            注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
                // 没有参数的情况
                let s1 = Symbol();
                let s2 = Symbol();
                s1 === s2 // false

                // 有参数的情况
                let s1 = Symbol('foo');
                let s2 = Symbol('foo');
                s1 === s2 // false
            上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。

            Symbol 值不能与其他类型的值进行运算，会报错。但是，Symbol 值可以显式转为字符串 toString()。

            另外，Symbol 值也可以转为布尔值，但是不能转为数值。
                let sym = Symbol();
                Boolean(sym) // true
                !sym  // false

                if (sym) {
                  // ...
                }
                Number(sym) // TypeError
                sym + 2 // TypeError

            实例属性description，直接返回 Symbol 的描述。
                const sym = Symbol('foo');
                sym.description // "foo"

            Symbol 值作为对象属性名时，不能用点运算符。
                const mySymbol = Symbol();
                const a = {};

                a.mySymbol = 'Hello!';
                a[mySymbol] // undefined
                a['mySymbol'] // "Hello!"
            上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。

            同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。
                let s = Symbol();
                let obj = {
                  [s]: function (arg) { ... }
                };
                obj[s](123);

            采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。
                let obj = {
                  [s](arg) { ... }
                };

            常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。
            还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。

            Object.getOwnPropertySymbols()方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名
            的 Symbol 值。另一个新的 API，Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。

                let s1 = Symbol.for('foo');
                let s2 = Symbol.for('foo');
                s1 === s2 // true
            Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()
            不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用
            Symbol.for("cat")30 次，每次都会返回同一个 Symbol 值，但是调用Symbol("cat")30 次，会返回 30 个不同的 Symbol 值。

            Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key。
                let s1 = Symbol.for("foo");
                Symbol.keyFor(s1) // "foo"

                let s2 = Symbol("foo");
                Symbol.keyFor(s2) // undefined
            上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。

            Symbol.isConcatSpreadable
            对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。
                let arr1 = ['c', 'd'];
                ['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
                arr1[Symbol.isConcatSpreadable] // undefined

                let arr2 = ['c', 'd'];
                arr2[Symbol.isConcatSpreadable] = false;
                ['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
            上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。

            类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。
                let obj = {length: 2, 0: 'c', 1: 'd'};
                ['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']

                obj[Symbol.isConcatSpreadable] = true;
                ['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']

            Symbol 的更多操作见 12 章节
        */

        /*
   // Set
            ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
            Set本身是一个构造函数，用来生成 Set 数据结构。
            在 Set 内部，两个NaN是相等的。
            另外，两个对象总是不相等的。
                const s = new Set();
                [2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

                for (let i of s) {
                  console.log(i);
                }
                // 2 3 5 4

                // 例一
                const set = new Set([1, 2, 3, 4, 4]);
                [...set]
                // [1, 2, 3, 4]

                // 例二
                const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
                items.size // 5

                // 例三
                const set = new Set(document.querySelectorAll('div'));
                set.size // 56

                let set = new Set();
                set.add({});
                set.size // 1

                set.add({});
                set.size // 2
            上面代码表示，由于两个空对象不相等，所以它们被视为两个值。

            Set 结构的实例有以下属性。
            Set.prototype.constructor：构造函数，默认就是Set函数。
            Set.prototype.size：返回Set实例的成员总数。
            Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。

            Set.prototype.add(value)：添加某个值，返回 Set 结构本身。
            Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
            Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。
            Set.prototype.clear()：清除所有成员，没有返回值。

            Array.from方法可以将 Set 结构转为数组。
            这就提供了去除数组重复成员的另一种方法。
                const items = new Set([1, 2, 3, 4, 5]);
                const array = Array.from(items);

            Set 结构的实例有四个遍历方法，可以用于遍历成员。
                Set.prototype.keys()：返回键名的遍历器
                Set.prototype.values()：返回键值的遍历器
                Set.prototype.entries()：返回键值对的遍历器
                Set.prototype.forEach()：使用回调函数遍历每个成员

            由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。
            这意味着，可以省略values方法，直接用for...of循环遍历 Set。
                let set = new Set(['red', 'green', 'blue']);

                for (let item of set.keys()) {
                  console.log(item);
                }
                // red
                // green
                // blue

                for (let item of set.values()) {
                  console.log(item);
                }
                // red
                // green
                // blue

                for (let item of set.entries()) {
                  console.log(item);
                }
                // ["red", "red"]
                // ["green", "green"]
                // ["blue", "blue"]

            Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。
                let set = new Set([1, 4, 9]);
                set.forEach((value, key) => console.log(key + ' : ' + value))
                // 1 : 1
                // 4 : 4
                // 9 : 9

            扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。
                let set = new Set(['red', 'green', 'blue']);
                let arr = [...set];
                // ['red', 'green', 'blue']

            扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。
                let arr = [3, 5, 2, 2, 5, 5];
                let unique = [...new Set(arr)];
                // [3, 5, 2]

            而且，数组的map和filter方法也可以间接用于 Set 了。
                let set = new Set([1, 2, 3]);
                set = new Set([...set].map(x => x * 2));
                // 返回Set结构：{2, 4, 6}

                let set = new Set([1, 2, 3, 4, 5]);
                set = new Set([...set].filter(x => (x % 2) == 0));
                // 返回Set结构：{2, 4}

            因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。
                let a = new Set([1, 2, 3]);
                let b = new Set([4, 3, 2]);

                // 并集
                let union = new Set([...a, ...b]);
                // Set {1, 2, 3, 4}

                // 交集
                let intersect = new Set([...a].filter(x => b.has(x)));
                // set {2, 3}

                // （a 相对于 b 的）差集
                let difference = new Set([...a].filter(x => !b.has(x)));
                // Set {1}

            WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
            首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
            WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。
            ES6 规定 WeakSet 不可遍历。

            WeakSet 结构有以下三个方法。
                WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
                WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
                WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
            WeakSet 没有size属性，没有办法遍历它的成员。
        */

        /*
    // Map
                const map = new Map([
                  ['name', '张三'],
                  ['title', 'Author']
                ]);

                map.size // 2
                map.has('name') // true
                map.get('name') // "张三"
                map.has('title') // true
                map.get('title') // "Author"

            如果读取一个未知的键，则返回undefined。
                new Map().get('asfddfsasadf')
                // undefined

            如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值
            true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。

                let map = new Map();

                map.set(-0, 123);
                map.get(+0) // 123

                map.set(true, 1);
                map.set('true', 2);
                map.get(true) // 1

                map.set(undefined, 3);
                map.set(null, 4);
                map.get(undefined) // 3

                map.set(NaN, 123);
                map.get(NaN) // 123

            （1）size 属性返回 Map 结构的成员总数。
            （2）Map.prototype.set(key, value)
            （3）Map.prototype.get(key)
            （4）Map.prototype.has(key)
            （5）Map.prototype.delete(key)
            （6）Map.prototype.clear()清除所有成员，没有返回值。

            遍历方法
            Map 结构原生提供三个遍历器生成函数和一个遍历方法。
                Map.prototype.keys()：返回键名的遍历器。
                Map.prototype.values()：返回键值的遍历器。
                Map.prototype.entries()：返回所有成员的遍历器。
                Map.prototype.forEach()：遍历 Map 的所有成员。
            需要特别注意的是，Map 的遍历顺序就是插入顺序。

            Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。
                const map = new Map([
                  [1, 'one'],
                  [2, 'two'],
                  [3, 'three'],
                ]);

                [...map.keys()]
                // [1, 2, 3]

                [...map.values()]
                // ['one', 'two', 'three']

                [...map.entries()]
                // [[1,'one'], [2, 'two'], [3, 'three']]

                [...map]
                // [[1,'one'], [2, 'two'], [3, 'three']]

            结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。
                const map0 = new Map()
                  .set(1, 'a')
                  .set(2, 'b')
                  .set(3, 'c');

                const map1 = new Map(
                  [...map0].filter(([k, v]) => k < 3)
                );
                // 产生 Map 结构 {1 => 'a', 2 => 'b'}

                const map2 = new Map(
                  [...map0].map(([k, v]) => [k * 2, '_' + v])
                    );
                // 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}

            与其他数据结构的互相转换
            （1）Map 转为数组
            前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（...）。
                const myMap = new Map()
                  .set(true, 7)
                  .set({foo: 3}, ['abc']);
                [...myMap]
                // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]

            （2）数组 转为 Map
            将数组传入 Map 构造函数，就可以转为 Map。
                new Map([
                  [true, 7],
                  [{foo: 3}, ['abc']]
                ])
                // Map {
                //   true => 7,
                //   Object {foo: 3} => ['abc']
                // }

            （3）Map 转为对象
            如果所有 Map 的键都是字符串，它可以无损地转为对象。
                function strMapToObj(strMap) {
                  let obj = Object.create(null);
                  for (let [k,v] of strMap) {
                    obj[k] = v;
                  }
                  return obj;
                }

                const myMap = new Map()
                  .set('yes', true)
                  .set('no', false);
                strMapToObj(myMap)
                // { yes: true, no: false }
            如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。

            （4）对象转为 Map
            对象转为 Map 可以通过Object.entries()。
                let obj = {"a":1, "b":2};
                let map = new Map(Object.entries(obj));
                此外，也可以自己实现一个转换函数。

                function objToStrMap(obj) {
                  let strMap = new Map();
                  for (let k of Object.keys(obj)) {
                    strMap.set(k, obj[k]);
                  }
                  return strMap;
                }

                objToStrMap({yes: true, no: false})
                // Map {"yes" => true, "no" => false}

            （5）Map 转为 JSON
            Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。
                function strMapToJson(strMap) {
                  return JSON.stringify(strMapToObj(strMap));
                }

                let myMap = new Map().set('yes', true).set('no', false);
                strMapToJson(myMap)
                // '{"yes":true,"no":false}'
                另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。

                function mapToArrayJson(map) {
                  return JSON.stringify([...map]);
                }

                let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
                mapToArrayJson(myMap)
                // '[[true,7],[{"foo":3},["abc"]]]'

            （6）JSON 转为 Map
            JSON 转为 Map，正常情况下，所有键名都是字符串。
                function jsonToStrMap(jsonStr) {
                  return objToStrMap(JSON.parse(jsonStr));
                }

                jsonToStrMap('{"yes": true, "no": false}')
                // Map {'yes' => true, 'no' => false}
                但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。

                function jsonToMap(jsonStr) {
                  return new Map(JSON.parse(jsonStr));
                }

                jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
                // Map {true => 7, Object {foo: 3} => ['abc']}

            WeakMap：
            WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
                const map = new WeakMap();
                map.set(key, 2)
            WeakMap只有四个方法可用：get()、set()、has()、delete()。
            WeakMap 应用的典型场合就是 DOM 节点作为键名,另一个用处是部署私有属性。（13章节末尾）
        */

        /*
    // Proxy
            Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过
            滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

            ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。
                var proxy = new Proxy(target, handler);
            Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所
            要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

            读取属性行为的例子：
                var proxy = new Proxy({}, {
                  get: function(target, propKey) {
                    return 35;
                  }
                });

                proxy.time // 35
                proxy.name // 35
                proxy.title // 35
            由于拦截函数总是返回35，所以访问任何属性都得到35。要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标
            对象（上例是空对象）进行操作。

            同一个拦截器函数，可以设置拦截多个操作。
            下面是 Proxy 支持的拦截操作一览，一共 13 种。
                get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy['foo']。
                set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
                has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。
                construct(target, args, newTarget):拦截new命令
                deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。
                ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、
                                for...in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
                getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
                defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、
                                                           Object.defineProperties(proxy, propDescs)，返回一个布尔值。
                preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。
                getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。
                isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。
                setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
                apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
                construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。

            get():
                var person = {
                  name: "张三"
                };

                var proxy = new Proxy(person, {
                  get: function(target, propKey) {
                    if (propKey in target) {
                      return target[propKey];
                    } else {
                      throw new ReferenceError("Prop name \"" + propKey + "\" does not exist.");
                    }
                  }
                });
                proxy.name // "张三"
                proxy.age // 抛出一个错误
            上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。

                const proxy = new Proxy({}, {
                  get: function(target, key, receiver) {
                    return receiver;
                  }
                });
                proxy.getReceiver === proxy // true
            上面代码中，proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。

                const proxy = new Proxy({}, {
                  get: function(target, key, receiver) {
                    return receiver;
                  }
                });

                const d = Object.create(proxy);
                d.a === d // true
            上面代码中，d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。

            set():
                let validator = {
                  set: function(obj, prop, value) {
                    if (prop === 'age') {
                      if (!Number.isInteger(value)) {
                        throw new TypeError('The age is not an integer');
                      }
                      if (value > 200) {
                        throw new RangeError('The age seems invalid');
                      }
                    }

                    // 对于满足条件的 age 属性以及其他属性，直接保存
                    obj[prop] = value;
                  }
                };

                let person = new Proxy({}, validator);

                person.age = 100;

                person.age // 100
                person.age = 'young' // 报错
                person.age = 300 // 报错
            上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。

            下面是set方法第四个参数的例子。
                const handler = {
                  set: function(obj, prop, value, receiver) {
                    obj[prop] = receiver;
                  }
                };
                const proxy = new Proxy({}, handler);
                proxy.foo = 'bar';
                proxy.foo === proxy // true
            上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身，请看下面的例子。

                const handler = {
                  set: function(obj, prop, value, receiver) {
                    obj[prop] = receiver;
                  }
                };
                const proxy = new Proxy({}, handler);
                const myObj = {};
                Object.setPrototypeOf(myObj, proxy);

                myObj.foo = 'bar';
                myObj.foo === myObj // true
            上面代码中，设置myObj.foo属性的值时，myObj并没有foo属性，因此引擎会到myObj的原型链去找foo属性。myObj的原型对象proxy是一个
            Proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myObj。 * 难点 *

            apply():
            apply方法拦截函数的调用、call和apply操作。
            apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
                var target = function () { return 'I am the target'; };
                var handler = {
                  apply: function () {
                    return 'I am the proxy';
                  }
                };

                var p = new Proxy(target, handler);

                p()
                // "I am the proxy"
            上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。
            另外，直接调用Reflect.apply方法，也会被拦截。

            has():
            has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
            has方法可以接受两个参数，分别是目标对象、需查询的属性名。

            下面的例子使用has方法隐藏某些属性，不被in运算符发现。
                var handler = {
                  has (target, key) {
                    if (key[0] === '_') {
                      return false;
                    }
                    return key in target;
                  }
                };
                var target = { _prop: 'foo', prop: 'foo' };
                var proxy = new Proxy(target, handler);
                '_prop' in proxy // false
            上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回false，从而不会被in运算符发现。

            更多内容 -> 14章节

    // Reflect
            Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。
            （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object
            和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。
            （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一
            个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。
                // 老写法
                try {
                  Object.defineProperty(target, property, attributes);
                  // success
                } catch (e) {
                  // failure
                }

                // 新写法
                if (Reflect.defineProperty(target, property, attributes)) {
                  // success
                } else {
                  // failure
                }
            （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和
            Reflect.deleteProperty(obj, name)让它们变成了函数行为。
                // 老写法
                'assign' in Object // true

                // 新写法
                Reflect.has(Object, 'assign') // true
            （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以
            方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。

            Reflect对象一共有 13 个静态方法。
                Reflect.apply(target, thisArg, args)
                Reflect.construct(target, args)
                Reflect.get(target, name, receiver)
                Reflect.set(target, name, value, receiver)
                Reflect.defineProperty(target, name, desc)
                Reflect.deleteProperty(target, name)
                Reflect.has(target, name)
                Reflect.ownKeys(target)
                Reflect.isExtensible(target)
                Reflect.preventExtensions(target)
                Reflect.getOwnPropertyDescriptor(target, name)
                Reflect.getPrototypeOf(target)
                Reflect.setPrototypeOf(target, prototype)
            上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。

            以 get() 为例：
            Reflect.get(target, name, receiver)     查找并返回target对象的name属性，如果没有该属性，则返回undefined。
                var myObject = {
                  foo: 1,
                  bar: 2,
                  get baz() {
                    return this.foo + this.bar;
                  },
                }

                Reflect.get(myObject, 'foo') // 1
                Reflect.get(myObject, 'bar') // 2
                Reflect.get(myObject, 'baz') // 3

            更多内容 -> 15章节
        */

        /*
   // Promise

            与同异步操作有关 -> 16章节

                let promise = new Promise(function(resolve, reject) {
                  console.log('Promise');
                  resolve();
                });

                promise.then(function() {
                  console.log('resolved.');
                  // success
                }, function(error) {
                  // failure
                });

                console.log('Hi!');

                // Promise
                // Hi!
                // resolved

            上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执
            行，所以resolved最后输出。

            then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。

                new Promise((resolve, reject) => {
                  resolve(1);
                  console.log(2);
                }).then(r => {
                  console.log(r);
                });
                // 2
                // 1
            上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本
            轮事件循环的末尾执行，总是晚于本轮循环的同步任务。

            一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后
            面。所以，最好在它们前面加上return语句，这样就不会有意外。
                new Promise((resolve, reject) => {
                  return resolve(1);
                  // 后面的语句不会执行
                  console.log(2);
                })

            Promise.prototype.finally()
            finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。
                promise
                .then(result => {···})
                .catch(error => {···})
                .finally(() => {···});
            上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。finally方法里面的
            操作，是与状态无关的，不依赖于 Promise 的执行结果。

            Promise.all()
            Promise.race()
            Promise.allSettled()
            Promise.any()

        */

        /*
   // Loop 循环的用法
            一个好的解释：for in 和 for of: https://www.jb51.net/article/70106.htm
                                         https://www.cnblogs.com/amujoe/p/8875053.html

            JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。

                var arr = ['a', 'b', 'c', 'd'];

                for (let a in arr) {
                  console.log(a); // 0 1 2 3
                }

                for (let a of arr) {
                  console.log(a); // a b c d
                }


        */

        /*
    // Generator -> 更多用于与 Promise 共同使用作为 异步任务的封装
            <Generator.html>
                function* foo(x, y) { ··· }

                function* foo(x) {
                  var y = 2 * (yield (x + 1));
                  var z = yield (y / 3);
                  return (x + y + z);
                }

                var a = foo(5);
                a.next() // Object{value:6, done:false}
                a.next() // Object{value:NaN, done:false}
                a.next() // Object{value:NaN, done:true}

                var b = foo(5);
                b.next() // { value:6, done:false }
                b.next(12) // { value:8, done:false }
                b.next(13) // { value:42, done:true }
            上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），除以 3 以后还是NaN，因此返回对象的value
            属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。
            如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield
            表达式的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，这时x等于5，y等
            于24，所以return语句的值等于42。

            yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。

            yield表达式如果用在另一个表达式之中，必须放在圆括号里面。
                function* demo() {
                  console.log('Hello' + yield); // SyntaxError
                  console.log('Hello' + yield 123); // SyntaxError

                  console.log('Hello' + (yield)); // OK
                  console.log('Hello' + (yield 123)); // OK
                }

            一个通过next方法的参数，向 Generator 函数内部输入值的例子：
                function* dataConsumer() {
                  console.log('Started');
                  console.log(`1. ${yield}`);
                  console.log(`2. ${yield}`);
                  return 'result';
                }

                let genObj = dataConsumer();
                genObj.next();
                // Started
                genObj.next('a')
                // 1. a
                genObj.next('b')
                // 2. b
            上面代码是一个很直观的例子，每次通过next方法向 Generator 函数输入值，然后打印出来。

            Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。
                function* gen() {
                  yield 1;
                  yield 2;
                  yield 3;
                }

                var g = gen();

                g.next()        // { value: 1, done: false }
                g.return('foo') // { value: "foo", done: true }
                g.next()        // { value: undefined, done: true }
            上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator 函数的遍历就终止了，返回值
            的done属性为true，以后再调用next方法，done属性总是返回true。
            如果return方法调用时，不提供参数，则返回值的value属性为undefined。

            如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。

                function* numbers () {
                  yield 1;
                  try {
                    yield 2;
                    yield 3;
                  } finally {
                    yield 4;
                    yield 5;
                  }
                  yield 6;
                }
                var g = numbers();
                g.next() // { value: 1, done: false }
                g.next() // { value: 2, done: false }
                g.return(7) // { value: 4, done: false }
                g.next() // { value: 5, done: false }
                g.next() // { value: 7, done: true }
            上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。

            yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for...of循环。

                function* concat(iter1, iter2) {
                  yield* iter1;
                  yield* iter2;
                }

                // 等同于
                function* concat(iter1, iter2) {
                  for (var value of iter1) {
                    yield value;
                  }
                  for (var value of iter2) {
                    yield value;
                  }
                }
            实际上，任何数据结构只要有 Iterator 接口，就可以被yield*遍历。

            如果一个对象的属性是 Generator 函数，可以简写成下面的形式。
                let obj = {
                  * myGeneratorMethod() {
                    ···
                  }
                };
                上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。

                // 等同于
                let obj = {
                  myGeneratorMethod: function* () {
                    // ···
                  }
                };

            this:(good example)
                function* F() {
                  this.a = 1;
                  yield this.b = 2;
                  yield this.c = 3;
                }
                var obj = {};
                var f = F.call(obj);

                f.next();  // Object {value: 2, done: false}
                f.next();  // Object {value: 3, done: false}
                f.next();  // Object {value: undefined, done: true}

                obj.a // 1
                obj.b // 2
                obj.c // 3

            更多：18，19 章节
        */

        /*



        */

        /*
            疑难杂症：
            https://es6.ruanyifeng.com/#README
            4-字符串的扩展
            6-正则的扩展  正则表达式
            9-数组的拓展  后半部分
            14 15 - proxy and reflect
        */

    </script>
</body>
</html>